---
title: "4Clojure for learning Clojure"
categories: clojure
---

## I completed all of the 4clojure problems!

After four weeks of consistent focus I made it through all 156 problems on
[4clojure.com][4clojure] Proof: [my user page][devm33] and [Top 100
users][users]

You can also see most of my solutions in the [github repo][github] I used for
this project. I only committed the problems to the repo that I needed to develop
inside the editor/repl, whereas some problems were simple enough to be solved on
the website. So the ones in the repo should be the more interesting problems.

The most interesting problems and solutions I'd like to share here. Warning:
this is spoilers for 4clojure of course. And if you're interested in learning
clojure I'd highly recommend not reading this and attempting the problems
yourself. The problems range from teaching you the basics of the language all
the way to really quite challenging. Each problem is presented with a set of
unit tests. Then once you solve a problem you can see everyone else's solutions,
which is great for benchmarking yourself and picking up other people's tricks.

This was my first adventure into clojure and I found the 4clojure problems great
for motivating me through the initial learning curve and maybe a bit past it. Of
course after 4 weeks I'm definitely still a beginner with clojure so any
feedback is welcomed!

## Fibonacci

<http://www.4clojure.com/problem/26>

The classic Fibonacci series problem. A goto for learning any language
especially a functional language. This was the first problem I had to write down
because I kept tripping myself with how `conj` adds to the begining of lists. This
frustration is definitely appreciatable in my submitted solution.


{% highlight clojure %}

(defn fib [n]
    (if (< n 3)
      (repeat n 1)
      (let
        [prev (reverse (fib (dec n)))]
        (reverse (conj prev (+ (first prev) (second prev)))))))

{% endhighlight %}

This approaches works but is pretty kludgy and far from efficient. To take
another crack at this knowing what I know now I'd opt for using a lazy sequence.

{% highlight clojure %}

(defn fibo [n]
  (letfn [(fib [a b] (cons a (lazy-seq (fib b (+ a b)))))]
    (take n (fib 1 1))))

{% endhighlight %}

Another good approach would be using `loop` and `recur`.


{% highlight clojure %}

(defn fibloop [n]
  (loop [remain n ret [] a 0 b 1]
    (if (= 0 remain) ret
      (recur (dec remain)
             (conj ret a)
             b
             (+ a b)))))

{% endhighlight %}

[4clojure]: http://www.4clojure.com/
[devm33]: http://www.4clojure.com/user/devm33
[users]: http://www.4clojure.com/users
[github]: https://github.com/devm33/4clojure_problems
